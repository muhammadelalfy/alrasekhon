<?php

namespace App\Http\Controllers\Api\V1;

use App\Http\Controllers\Api\BaseApiController;
use App\Http\Requests\Api\V1\Arbitrators\ArbitratorRequest;
use App\Http\Resources\ArbitratorResource;
use App\Models\Arbitrator;
use App\Models\File;
use App\Repositories\Contracts\ArbitratorContract;
use App\Traits\FileUploadTrait;
use App\Traits\JsonValidationTrait;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\ValidationException;

class ArbitratorController extends BaseApiController
{

    use JsonValidationTrait, FileUploadTrait;

    /**
     * ArbitratorController constructor.
     * @param ArbitratorContract $repository
     */
    public function __construct(ArbitratorContract $repository)
    {
        parent::__construct($repository, ArbitratorResource::class);
    }

    public function index(): mixed
    {
        if (request('get_for_statistics')){
            return Arbitrator::count();
        }
        return parent::index(); // TODO: Change the autogenerated stub
    }

    /**
     * Store a newly created resource in storage.
     * @param ArbitratorRequest $request
     */
    public function store(ArbitratorRequest $request)
    {
        $data = $request->all();
        $data['step_no'] = ($data['step_no'] + 1);
        $data['user_id'] = auth()->id();
        $arbitrator = $this->repository->create($data);
        return $this->respondWithModel($arbitrator);

    }

    /**
     * Display the specified resource.
     * @param Arbitrator $arbitrator
     * @return mixed
     */
    public function show(Arbitrator $arbitrator): mixed
    {
        return $this->respondWithModel($arbitrator);
    }

    /**
     * Update steps global function
     * @param Arbitrator $arbitrator
     * @param Request $request
     * @return mixed|void
     * @throws ValidationException
     */
    public function updateStep(Arbitrator $arbitrator, Request $request)
    {
        $step = $request->step_no;
        if ($step == 2){
            return $this->step2($arbitrator, $request);
        }
        if ($step == 3){
            return $this->step3($arbitrator, $request);
        }
        if ($step == 4){
            return $this->step4($arbitrator, $request);
        }
    }

    /**
     * Step one function
     * @param Arbitrator $arbitrator
     * @param $request
     * @return mixed
     * @throws ValidationException
     */
    private function step2(Arbitrator $arbitrator, $request): mixed
    {
        $qualificationRegex = "/^[a-zA-Z\p{Arabic}\s]+$/iu";
        $jobRegex = "/^[a-zA-Z\p{Arabic}\s]+$/iu";
        $practicalExperiencesRegex = "/^[a-zA-Z0-9\p{Arabic}\s]+$/iu";
        $companyNameRegex = "/^[a-zA-Z0-9\p{Arabic}\s]+$/iu";

        $rules = [
            'qualification' => ['required', 'min:1', 'max:200', 'regex:'.$qualificationRegex],
            'job' => ['required', 'min:1', 'max:200', 'regex:'.$jobRegex],
            'is_teacher' => ['nullable'],
            'work_experiences' => ['nullable', 'required_if:is_teacher,1'],
//            'company_name' => ['nullable', 'required_if:is_teacher,1,true', 'min:1', 'max:200', 'regex:'.$companyNameRegex],
//            'still_working' => ['nullable'],
//            'work_place_type' => ['nullable', 'required_if:still_working,1'],
            'practical_experiences' => ['required', 'array', 'min:1'],
        ];
        $attributes = [
            'qualification' => __('arbitrators.qualification'),
            'job' => __('arbitrators.job'),
            'is_teacher' => __('arbitrators.is_teacher'),
            'work_experiences' => __('arbitrators.work_experiences'),
            'company_name' => __('arbitrators.company_name'),
            'still_working' => __('arbitrators.still_working'),
            'work_place_type' => __('arbitrators.work_place_type'),
            'practical_experiences' => __('arbitrators.practical_experiences'),
            'practical_experience' => __('arbitrators.practical_experiences'),
        ];

        $messages = [
            'work_experiences.required_if' => __('arbitrators.work_experiences_required_if'),
            'company_name.required_if' => __('arbitrators.company_name_required_if'),
            'practical_experience.required' => __('arbitrators.practical_experience_required'),
        ];

        foreach ($request->practical_experiences as $practical_experience) {
            preg_match($practicalExperiencesRegex, $practical_experience, $match);
            if (mb_strlen($practical_experience) < 1 || mb_strlen($practical_experience) > 200 || !count($match)){
                $rules['practical_experience'] = ['required', 'min:1', 'max:200', 'regex:'.$practicalExperiencesRegex];
            }
        }


        $validator = Validator::make($request->all(), $rules, $messages, $attributes);


        if ($validator->fails()){
            $this->failedValidation($validator);
        }


        $arbitrator = $this->repository->update($arbitrator, $validator->validate());
        $arbitrator->update(['step_no' => ($request->step_no+1)]);
        return $this->respondWithModel($arbitrator);
    }

    /**
     * Step two function
     * @param Arbitrator $arbitrator
     * @param $request
     * @return mixed
     * @throws ValidationException
     */
    private function step3(Arbitrator $arbitrator, $request): mixed
    {

        $authorizationRegex = "/^[a-zA-Z0-9\p{Arabic}\s]+$/iu";

        $rules = [
            'methods_readings_ids' => ['required', 'array'],
            'authorizations' => ['required', 'array', 'min:1'],
            'vocation_bonds_attaches' => ['required', 'array'], // , 'mimes:jpg,jpeg,png,pdf', 'max:5120'
        ];
        $attributes = [
            'methods' => __('arbitrators.methods'),
            'readings' => __('arbitrators.readings'),
            'novels' => __('arbitrators.novels'),
            'authorizations' => __('arbitrators.authorizations'),
            'authorization' => __('arbitrators.authorizations'),
            'vocation_bonds_attaches' => __('arbitrators.vocation_bonds_attaches'),
            'methods_readings_ids' => __('arbitrators.methods_readings_ids'),
        ];

        $messages = [
            'authorization.required' => __('arbitrators.authorization_required')
        ];

        foreach ($request->authorizations as $authorization) {
            preg_match($authorizationRegex, $authorization, $match);
            if (mb_strlen($authorization) < 1 || mb_strlen($authorization) > 200 || !count($match)){
                $rules['authorization'] = ['required', 'min:1', 'max:200', 'regex:'.$authorizationRegex];
            }
        }

        $validator = Validator::make($request->all(), $rules, $messages, $attributes);

        if ($validator->fails()){
            $this->failedValidation($validator);
        }


        $attributes = $validator->validate();
        $attributes['authorizations'] = [];

        foreach ($request->authorizations as $key => $authorization) {
            $attributes['authorizations'][] = [
                'authorization' => $authorization,
                'attach_url' => Storage::url($request->vocation_bonds_attach_urls[$key]),
                'attach_id' => $request->vocation_bonds_attaches[$key],
            ];
        }



        $methodsReadingsIds = array_filter($request->methods_readings_ids, function ($value){
            return $value;
        });


        $arbitrator->readings()->detach();
        foreach ($methodsReadingsIds as $methodId => $readingsIds) {
            $arbitrator->readings()->attach($readingsIds);
            $arbitrator->readings()->updateExistingPivot($readingsIds, ['method_id' => $methodId]);
        }


        $arbitrator = $this->repository->update($arbitrator, $attributes);
        $arbitrator->update(['step_no' => ($request->step_no+1)]);
        return $this->respondWithModel($arbitrator);
    }

    /**
     * Step four function
     * @param Arbitrator $arbitrator
     * @param $request
     * @return mixed
     * @throws ValidationException
     */
    private function step4(Arbitrator $arbitrator, $request): mixed
    {
        $addressRegex = "/^[a-zA-Z0-9\p{Arabic}\s]+$/iu";


        $rules = [
            'country_id' => ['required', 'exists:countries,id'],
            'governorate_id' => ['required', 'exists:governorates,id'],
            'city_id' => ['required', 'exists:cities,id'],
            'main_address' => ['required', 'min:1', 'max:200', 'regex:'.$addressRegex],
            'additional_address' => ['required', 'min:1', 'max:200', 'regex:'.$addressRegex],
        ];
        $attributes = [
            'country_id' => __('arbitrators.country_id'),
            'governorate_id' => __('arbitrators.governorate_id'),
            'city_id' => __('arbitrators.city_id'),
            'main_address' => __('arbitrators.main_address'),
            'additional_address' => __('arbitrators.additional_address'),
        ];

        $messages = [];

        $validator = Validator::make($request->all(), $rules, $messages, $attributes);

        if ($validator->fails()){
            $this->failedValidation($validator);
        }

        $arbitrator = $this->repository->update($arbitrator, $validator->validate());
        $arbitrator->update(['step_no' => null]);
        return $this->respondWithModel($arbitrator);
    }

    /**
     * Add, update, work experience
     * @param Arbitrator $arbitrator
     * @param Request $request
     * @return mixed
     * @throws ValidationException
     */
    public function addWorkExperience(Arbitrator $arbitrator, Request $request): mixed
    {

        $companyNameRegex = "/^[a-zA-Z0-9\p{Arabic}\s]+$/iu";
        $rules = [
            'company_name' => ['required', 'min:1', 'max:200', 'regex:'.$companyNameRegex],
            'still_working' => ['nullable'],
            'work_place_type' => ['nullable', 'required_if:still_working,1,true', 'in:eligibility,government,memorization'],
            'work_place_proof_attach_id' => ['nullable', 'required_if:still_working,1,true', 'exists:files,id'],
        ];

        $attributes = [
            'company_name' => __('arbitrators.company_name'),
            'still_working' => __('arbitrators.still_working'),
            'work_place_type' => __('arbitrators.work_place_type'),
            'work_place_proof_attach_id' => __('arbitrators.work_place_proof_attachment'),
        ];

        $messages = [
            'work_place_type.required_if' => __('arbitrators.work_place_type_required'),
            'work_place_proof_attach_id.required_if' => __('arbitrators.work_place_proof_attach_required'),
        ];

        $validator = Validator::make($request->all(), $rules, $messages, $attributes);

        if ($validator->fails()){
            $this->failedValidation($validator);
        }

        $data = [
            'arbitrator_id' => $arbitrator->id,
            'company_name' => $request->company_name,
//            'still_working' => in_array($request->still_working, [1,true]) ? 1 : 0,
            'still_working' => (boolean) $request->still_working,
            'work_place_type' => $request->work_place_type,
            'work_place_proof_attach_id' => $request->work_place_proof_attach_id,
            'attach_url' => $request->attach_updated ? Storage::url($request->attach_url) : $request->attach_url,
            'work_experiences_index' => $request->work_experiences_index,
        ];

        $arbitrator = $this->repository->addWorkExperience($arbitrator, $data);
        return $this->respondWithModel($arbitrator);

    }

    /**
     * Delete work experience
     * @param Arbitrator $arbitrator
     * @param Request $request
     * @return mixed
     */
    public function deleteWorkExperience(Arbitrator $arbitrator, Request $request): mixed
    {

        $workExperiences = $arbitrator->work_experiences;
        $file = File::find($workExperiences[$request->index]['work_place_proof_attach_id']);
        if ($file){
            $this->deleteFile($file);
        }

        unset($workExperiences[$request->index]);

        $attributes['work_experiences'] = array_values($workExperiences);

        $arbitrator = $this->repository->deleteWorkExperience($arbitrator, $attributes);
        return $this->respondWithModel($arbitrator);
    }


    public function addReading(Arbitrator $arbitrator, Request $request)
    {
        $arbitrator = $this->repository->addReading($arbitrator, $request->all());
        return $this->respondWithModel($arbitrator);
    }

    public function deleteReading(Arbitrator $arbitrator, Request $request)
    {
        $arbitrator = $this->repository->deleteReading($arbitrator, $request->all());
        return $this->respondWithModel($arbitrator);
    }


    /**
     * Update the specified resource in storage.
     *
     * @param ArbitratorRequest $request
     * @param Arbitrator $arbitrator
     * @return mixed
     */
    public function update(ArbitratorRequest $request, Arbitrator $arbitrator): mixed
    {
        $arbitrator = $this->repository->update($arbitrator, $request->validated());
        $arbitrator->update(['step_no' => ($request->step_no + 1)]);
        return $this->respondWithModel($arbitrator);
    }

    /**
     * Remove the specified resource from storage.
     * @param Arbitrator $arbitrator
     * @return JsonResponse
     */
    public function destroy(Arbitrator $arbitrator): JsonResponse
    {
        if (count($arbitrator->files ?? [])){
            $this->deleteFiles($arbitrator->files);
        }
        $this->repository->remove($arbitrator);
        return $this->respondWithSuccess(__('Arbitrator Deleted Successfully'));
    }

    /**
     * Toggle level status
     * @return JsonResponse
     */
    public function toggle(): JsonResponse
    {
        $this->repository->toggleField(request()->id , 'status');
        return $this->respondWithSuccess(__('general.Status Changed Successfully'));
    }

    public function upload(Request $request)
    {
        // To delete old work experience attach
        if ($request->old_attach_id){
            $oldFile = File::find($request->old_attach_id);
            if ($oldFile){
                $this->deleteFile($oldFile);
            }
        }
        $uploaded = $this->repository->uploadFile($request);
        return $uploaded;
    }

}
